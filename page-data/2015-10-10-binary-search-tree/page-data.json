{"componentChunkName":"component---src-templates-blog-post-js","path":"/2015-10-10-binary-search-tree/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Swapnil Mishra Blog"}},"markdownRemark":{"id":"192695a5-73a8-5725-8a61-f58d2ccb5596","excerpt":"What is a binary search tree? In a nutshell a binary search tree is a type of tree with property  for every node. Creating the tree First let us create a node…","html":"<h3>What is a binary search tree?</h3>\n<p>In a nutshell a binary search tree is a type of tree with property <code class=\"language-text\">left &lt; parent &lt; right</code> for every node.</p>\n<h3>Creating the tree</h3>\n<p>First let us create a node object which will form the basis of our tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function TreeEl() {\n    this.left = null  // holds reference of tree&#39;s left node\n    this.right = null // holds reference of tree&#39;s right node\n    this.value = null // holds the value of the node\n}</code></pre></div>\n<p>Just to visualize things in a better perspective, let us assume that we are given a list of numbers to create the binary search tree with. Given below is the list:</p>\n<p><code class=\"language-text\">[10, 9, 2, 1, 7, 3, 4, 6, 5, 8]</code></p>\n<p>Lets create a <code class=\"language-text\">makeBinarySearchTree</code> function which would loop over all these items thereby adding them to tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function makeBinarySearchTree(arr) {\n\n    // initialize parent node(which will be 10 in our case) with our tree object\n    var parent = new TreeEl();\n\n    for (var i = 0; i &lt; arr.length; i++) {\n        // First element of the array forms the parent.\n        // Initialize the parent, and continue the loop.\n        // Else add the element to its appropriate place\n        // in the tree.\n        if (i === 0) {\n            parent.value = arr[i]\n            continue;\n        }\n        // In all other cases call addNode passing value\n        // and parent\n        addNode(arr[i], parent)\n    }\n    // return parent which holds the reference to it.\n    return parent;\n\n}</code></pre></div>\n<p><code class=\"language-text\">addNode</code> function shown in the above code snippet is the basis of the tree formation. Given below is the code for <code class=\"language-text\">addNode</code> function:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/*\n  {@param : value} value which need to be inserted into the tree\n  {@param : value} parent node of the tree\n*/\nfunction addNode(value, parent) {\n/*\n1. Call findNodeToInsert to figure out at what node the value will be inserted.\n2. If the value need to be inserted at the left of the returned node create a new tree object at the  left of the returned node and initialize its value.\n3. Repeat the same procedure in case the value need to be inserted at the right of the returned node.\n*/\n    var elm = findNodeToInsert(value, parent)\n    if (elm.where === &#39;left&#39;) {\n        elm.node.left = new TreeEl()\n        elm.node.left.value = value\n    }\n    else if (elm.where === &#39;right&#39;) {\n        elm.node.right = new TreeEl()\n        elm.node.right.value = value\n    }\n    console.log(&#39;Inserting &#39; + value + &#39; at &#39; + elm.where + &#39; of &#39; + elm.node.value)\n}</code></pre></div>\n<p>Not much of logic is placed in the above show <code class=\"language-text\">addNode</code> function and should be easy to understand from the code comments. Its the <code class=\"language-text\">findNodeToInsert</code> function where things starts to get a bit tricky. Given below is the code for <code class=\"language-text\">findNodeToInsert</code> function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/*\n{@param : value} value which need to be inserted into the tree\n{@param : value} node of the tree\n*/\nfunction findNodeToInsert(value, node) {\n    if (value &lt; node.value) {\n        if (node.left) {\n            return findNodeToInsert(value, node.left)\n        }\n        else {\n            return {\n                node: node,\n                where: &#39;left&#39;\n            }\n        }\n    }\n    else if (value &gt; node.value) {\n        if (node.right) {\n            return findNodeToInsert(value, node.right)\n        }\n        else {\n            return {\n                node: node,\n                where: &#39;right&#39;\n            }\n        }\n    }\n    else {\n        return {\n            node: parent,\n            where: &#39;left&#39;\n        }\n    }\n}</code></pre></div>\n<p>Above code snippet will need a bit of explaining in details. We are using recursion here as a binary tree repeats itself at each node with the property <code class=\"language-text\">left &lt; parent &lt; right</code>. Using this property whatever logic we perform on a single node can be done on all of them recursively. Explaining this logic below:</p>\n<ol>\n<li>Fist check <code class=\"language-text\">if value &lt; node.value</code> i.e if the value which need to be inserted into the tree if greater than the value of node.</li>\n<li>Second, if the result of <strong>step 1</strong> is true, it means the value is going to be inserted to the left of the node/subtree. Please note that we still haven’t figured out the exact place of insertion but we know for sure that it would be at the left.</li>\n<li>Continuing on <strong>step 2</strong></li>\n<li>We first check if the node has a left element by checking <code class=\"language-text\">if (node.left)</code>, if this turns out be true, it means we have to walk further down the tree. We do that by invoking and returning <code class=\"language-text\">findNodeToInsert</code> recursively.</li>\n<li>If <code class=\"language-text\">if (node.left)</code> condition turns out to be false, it means we are at the node where the new tree node need to be created so we return from here passing the node reference and the place(<code class=\"language-text\">where</code>) where a new node need to be created. Note that this forms the basis of ending the recursion.</li>\n<li>If check of <strong>step 1</strong> fails we check <code class=\"language-text\">if (value &gt; node.value)</code>. This means we would have to walk the right subtree in the exact similar way we did for left subtree.</li>\n<li>At the end if checks of <strong>step 1</strong> and <strong>step 4</strong> fails we assume the to be inserted value equal to the value of the node being compared i.e <code class=\"language-text\">if (value === node.value)</code>. We consider these type of values to be inserted in left subtree.</li>\n</ol>\n<p>Result/return of <code class=\"language-text\">findNodeToInsert</code> will tell us the place and the node where a new node can be created. Post which we will create a new <code class=\"language-text\">Tree</code> object in our <code class=\"language-text\">addNode</code> function. Every time a new element is given to us we will have to use the same method of walking through the tree to figure out at which exact node a new node will be created.</p>\n<h1>Traversing the tree</h1>\n<p>A binary search tree can traversed in 3 ways. Each of the traversal derive its name by which the parent element is being visited.</p>\n<ul>\n<li>preorder - parent | left   | right</li>\n<li>inorder -  left   | parent | right</li>\n<li>postorder  left   | right  | parent</li>\n</ul>\n<p>Inorder traversal gives us a sorted array because of the property of tree that <code class=\"language-text\">left &lt; parent &lt; right</code>. e.g consider a tree just having 3 elements i.e the tree is 4(parent) 3(left) 5(right) now an inorder traversal will give is 3(left) 4 (parent) 5(right) which is the sorted order. So now we know why binary search tree are good for sorting.</p>\n<p>To achieve the traversal of Binary search tree we will again take help of recursion by walking through the tree starting from parent. To walk left we define a <code class=\"language-text\">walkLeft</code> function, to walk right we define a <code class=\"language-text\">walkRight</code> function.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function walkLeft(subtree,walk) {\n    if (subtree.left) {\n        return walk(subtree.left)\n    }\n}\n\nfunction walkRight(subtree,walk) {\n    if (subtree.right) {\n        return walk(subtree.right)\n    }\n}</code></pre></div>\n<p>Both of the above functions are higher order functions requiring a <code class=\"language-text\">walk</code> function as argument. <code class=\"language-text\">walk</code> function is the function from where the above functions will be invoked since we will have to recursively call the function by repeating the steps. The order with which <code class=\"language-text\">walkLeft</code> or <code class=\"language-text\">walkRight</code> are called will determine the type of traversal. Things will get more clear in the below section where we will be defining the <code class=\"language-text\">walk</code> function for inorder,preorder and postorder traversals.</p>\n<h2>In-order</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function walkLeft(subtree,walk) {\n    // check if there is node at the left subtree\n    // if yes, call the walk function again\n    if (subtree.left) {\n        return walk(subtree.left)\n    }\n}\n\nfunction walkRight(subtree,walk) {\n    // check if there is node at the right subtree\n    // if yes, call the walk function again\n    if (subtree.right) {\n        return walk(subtree.right)\n    }\n}\n\nfunction inOrderTraversal(tree) {\n\n    walk(tree)\n\n    function walk(subtree) {\n        walkLeft(subtree,walk)\n        console.log(subtree.value)\n        walkRight(subtree,walk)\n    }\n\n}</code></pre></div>\n<p>In the above code we define a walk function which calls <code class=\"language-text\">walkLeft</code> function first and then logging the value whenever it returns and then moving on to call <code class=\"language-text\">walkRight</code>. I have pasted <code class=\"language-text\">walkLeft</code> and <code class=\"language-text\">walkRight</code> functions with comments just to understand things better. This order of calling forms the basis of our recursion which in turn is the <code class=\"language-text\">walk</code> function being passed in <code class=\"language-text\">walkLeft</code> and <code class=\"language-text\">walkRight</code> functions. Because of recursion this step gets repeated on each of the node in the order. You might need a bit of recursion knowledge to understand this better but things get very easy after that.</p>\n<h2>Pre-order</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function preOrderTraversal(tree) {\n\n    walk(tree)\n\n    function walk(subtree) {\n        console.log(subtree.value)\n        walkLeft(subtree,walk)\n        walkRight(subtree,walk)\n    }\n\n}</code></pre></div>\n<h2>Post-order</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function postOrderTraversal(tree) {\n    walk(tree)\n\n        function walk(subtree) {\n            walkLeft(subtree,walk)\n            walkRight(subtree,walk)\n            console.log(subtree.value)\n        }\n    }\n}</code></pre></div>","frontmatter":{"title":"Building and walking a binary search tree","date":"October 18, 2016","description":"In this post we will see how to create a binary search tree from scratch and walk through it. Binary search tree are an important data structure as they allow fast lookup, addition and removal of items and reduces the time complexity to O(logn)."}}},"pageContext":{"slug":"/2015-10-10-binary-search-tree/","previous":null,"next":{"fields":{"slug":"/2015-10-10-jsbin-clone/"},"frontmatter":{"title":"How to build pastebins like jsbin, jsfiddle, dabblet"}}}}}